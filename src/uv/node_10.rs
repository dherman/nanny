/* automatically generated by rust-bindgen */

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__next as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
impl Default for __darwin_pthread_handler_rec {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
impl Default for _opaque_pthread_mutex_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
impl Default for _opaque_pthread_rwlock_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_t>())).__cleanup_stack as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__opaque as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
impl Default for _opaque_pthread_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_t = __darwin_pthread_t;
pub type mach_port_t = __darwin_mach_port_t;
pub type semaphore_t = mach_port_t;
pub type uv__io_cb = ::std::option::Option<
    unsafe extern "C" fn(loop_: *mut uv_loop_s, w: *mut uv__io_s, events: ::std::os::raw::c_uint),
>;
pub type uv__io_t = uv__io_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv__io_s {
    pub cb: uv__io_cb,
    pub pending_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub watcher_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub pevents: ::std::os::raw::c_uint,
    pub events: ::std::os::raw::c_uint,
    pub fd: ::std::os::raw::c_int,
    pub rcount: ::std::os::raw::c_int,
    pub wcount: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_uv__io_s() {
    assert_eq!(
        ::std::mem::size_of::<uv__io_s>(),
        64usize,
        concat!("Size of: ", stringify!(uv__io_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv__io_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv__io_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv__io_s>())).cb as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv__io_s),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv__io_s>())).pending_queue as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv__io_s),
            "::",
            stringify!(pending_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv__io_s>())).watcher_queue as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv__io_s),
            "::",
            stringify!(watcher_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv__io_s>())).pevents as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(uv__io_s),
            "::",
            stringify!(pevents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv__io_s>())).events as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(uv__io_s),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv__io_s>())).fd as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv__io_s),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv__io_s>())).rcount as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(uv__io_s),
            "::",
            stringify!(rcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv__io_s>())).wcount as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uv__io_s),
            "::",
            stringify!(wcount)
        )
    );
}
impl Default for uv__io_s {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type uv_thread_t = pthread_t;
pub type uv_mutex_t = pthread_mutex_t;
pub type uv_rwlock_t = pthread_rwlock_t;
pub type uv_sem_t = semaphore_t;
pub const uv_handle_type_UV_UNKNOWN_HANDLE: uv_handle_type = 0;
pub const uv_handle_type_UV_ASYNC: uv_handle_type = 1;
pub const uv_handle_type_UV_CHECK: uv_handle_type = 2;
pub const uv_handle_type_UV_FS_EVENT: uv_handle_type = 3;
pub const uv_handle_type_UV_FS_POLL: uv_handle_type = 4;
pub const uv_handle_type_UV_HANDLE: uv_handle_type = 5;
pub const uv_handle_type_UV_IDLE: uv_handle_type = 6;
pub const uv_handle_type_UV_NAMED_PIPE: uv_handle_type = 7;
pub const uv_handle_type_UV_POLL: uv_handle_type = 8;
pub const uv_handle_type_UV_PREPARE: uv_handle_type = 9;
pub const uv_handle_type_UV_PROCESS: uv_handle_type = 10;
pub const uv_handle_type_UV_STREAM: uv_handle_type = 11;
pub const uv_handle_type_UV_TCP: uv_handle_type = 12;
pub const uv_handle_type_UV_TIMER: uv_handle_type = 13;
pub const uv_handle_type_UV_TTY: uv_handle_type = 14;
pub const uv_handle_type_UV_UDP: uv_handle_type = 15;
pub const uv_handle_type_UV_SIGNAL: uv_handle_type = 16;
pub const uv_handle_type_UV_FILE: uv_handle_type = 17;
pub const uv_handle_type_UV_HANDLE_TYPE_MAX: uv_handle_type = 18;
pub type uv_handle_type = u32;
pub type uv_loop_t = uv_loop_s;
pub type uv_handle_t = uv_handle_s;
pub type uv_async_t = uv_async_s;
pub type uv_signal_t = uv_signal_s;
extern "C" {
    #[link_name = "\u{1}_uv_default_loop"]
    pub fn uv_default_loop() -> *mut uv_loop_t;
}
pub type uv_close_cb = ::std::option::Option<unsafe extern "C" fn(handle: *mut uv_handle_t)>;
pub type uv_async_cb = ::std::option::Option<unsafe extern "C" fn(handle: *mut uv_async_t)>;
pub type uv_signal_cb = ::std::option::Option<
    unsafe extern "C" fn(handle: *mut uv_signal_t, signum: ::std::os::raw::c_int),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uv_handle_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub u: uv_handle_s__bindgen_ty_1,
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uv_handle_s__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub reserved: [*mut ::std::os::raw::c_void; 4usize],
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_uv_handle_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<uv_handle_s__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(uv_handle_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_handle_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_handle_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_handle_s__bindgen_ty_1>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_handle_s__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_handle_s__bindgen_ty_1>())).reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_handle_s__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for uv_handle_s__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_uv_handle_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_handle_s>(),
        96usize,
        concat!("Size of: ", stringify!(uv_handle_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_handle_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_handle_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_handle_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_handle_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_handle_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_handle_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_handle_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_handle_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_handle_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_handle_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_handle_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_handle_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_handle_s>())).u as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_handle_s),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_handle_s>())).next_closing as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_handle_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_handle_s>())).flags as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_handle_s),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for uv_handle_s {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[link_name = "\u{1}_uv_close"]
    pub fn uv_close(handle: *mut uv_handle_t, close_cb: uv_close_cb);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uv_async_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub u: uv_async_s__bindgen_ty_1,
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
    pub async_cb: uv_async_cb,
    pub queue: [*mut ::std::os::raw::c_void; 2usize],
    pub pending: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uv_async_s__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub reserved: [*mut ::std::os::raw::c_void; 4usize],
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_uv_async_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<uv_async_s__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(uv_async_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_async_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_async_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s__bindgen_ty_1>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_async_s__bindgen_ty_1>())).reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for uv_async_s__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_uv_async_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_async_s>(),
        128usize,
        concat!("Size of: ", stringify!(uv_async_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_async_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_async_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).u as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).next_closing as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).flags as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).async_cb as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(async_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).queue as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).pending as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(pending)
        )
    );
}
impl Default for uv_async_s {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[link_name = "\u{1}_uv_async_init"]
    pub fn uv_async_init(
        arg1: *mut uv_loop_t,
        async: *mut uv_async_t,
        async_cb: uv_async_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_async_send"]
    pub fn uv_async_send(async: *mut uv_async_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uv_signal_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub u: uv_signal_s__bindgen_ty_1,
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
    pub signal_cb: uv_signal_cb,
    pub signum: ::std::os::raw::c_int,
    pub tree_entry: uv_signal_s__bindgen_ty_2,
    pub caught_signals: ::std::os::raw::c_uint,
    pub dispatched_signals: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uv_signal_s__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub reserved: [*mut ::std::os::raw::c_void; 4usize],
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_uv_signal_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<uv_signal_s__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(uv_signal_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_signal_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_signal_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s__bindgen_ty_1>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_signal_s__bindgen_ty_1>())).reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for uv_signal_s__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_signal_s__bindgen_ty_2 {
    pub rbe_left: *mut uv_signal_s,
    pub rbe_right: *mut uv_signal_s,
    pub rbe_parent: *mut uv_signal_s,
    pub rbe_color: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_uv_signal_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<uv_signal_s__bindgen_ty_2>(),
        32usize,
        concat!("Size of: ", stringify!(uv_signal_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_signal_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_signal_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_signal_s__bindgen_ty_2>())).rbe_left as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s__bindgen_ty_2),
            "::",
            stringify!(rbe_left)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_signal_s__bindgen_ty_2>())).rbe_right as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s__bindgen_ty_2),
            "::",
            stringify!(rbe_right)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_signal_s__bindgen_ty_2>())).rbe_parent as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s__bindgen_ty_2),
            "::",
            stringify!(rbe_parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_signal_s__bindgen_ty_2>())).rbe_color as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s__bindgen_ty_2),
            "::",
            stringify!(rbe_color)
        )
    );
}
impl Default for uv_signal_s__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_uv_signal_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_signal_s>(),
        152usize,
        concat!("Size of: ", stringify!(uv_signal_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_signal_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_signal_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).u as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).next_closing as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).flags as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).signal_cb as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(signal_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).signum as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(signum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).tree_entry as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(tree_entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).caught_signals as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(caught_signals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).dispatched_signals as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(dispatched_signals)
        )
    );
}
impl Default for uv_signal_s {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uv_loop_s {
    pub data: *mut ::std::os::raw::c_void,
    pub active_handles: ::std::os::raw::c_uint,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub active_reqs: uv_loop_s__bindgen_ty_1,
    pub stop_flag: ::std::os::raw::c_uint,
    pub flags: ::std::os::raw::c_ulong,
    pub backend_fd: ::std::os::raw::c_int,
    pub pending_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub watcher_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub watchers: *mut *mut uv__io_t,
    pub nwatchers: ::std::os::raw::c_uint,
    pub nfds: ::std::os::raw::c_uint,
    pub wq: [*mut ::std::os::raw::c_void; 2usize],
    pub wq_mutex: uv_mutex_t,
    pub wq_async: uv_async_t,
    pub cloexec_lock: uv_rwlock_t,
    pub closing_handles: *mut uv_handle_t,
    pub process_handles: [*mut ::std::os::raw::c_void; 2usize],
    pub prepare_handles: [*mut ::std::os::raw::c_void; 2usize],
    pub check_handles: [*mut ::std::os::raw::c_void; 2usize],
    pub idle_handles: [*mut ::std::os::raw::c_void; 2usize],
    pub async_handles: [*mut ::std::os::raw::c_void; 2usize],
    pub async_unused: ::std::option::Option<unsafe extern "C" fn()>,
    pub async_io_watcher: uv__io_t,
    pub async_wfd: ::std::os::raw::c_int,
    pub timer_heap: uv_loop_s__bindgen_ty_2,
    pub timer_counter: u64,
    pub time: u64,
    pub signal_pipefd: [::std::os::raw::c_int; 2usize],
    pub signal_io_watcher: uv__io_t,
    pub child_watcher: uv_signal_t,
    pub emfile_fd: ::std::os::raw::c_int,
    pub cf_thread: uv_thread_t,
    pub _cf_reserved: *mut ::std::os::raw::c_void,
    pub cf_state: *mut ::std::os::raw::c_void,
    pub cf_mutex: uv_mutex_t,
    pub cf_sem: uv_sem_t,
    pub cf_signals: [*mut ::std::os::raw::c_void; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uv_loop_s__bindgen_ty_1 {
    pub unused: [*mut ::std::os::raw::c_void; 2usize],
    pub count: ::std::os::raw::c_uint,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_uv_loop_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<uv_loop_s__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(uv_loop_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_loop_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_loop_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s__bindgen_ty_1>())).unused as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s__bindgen_ty_1),
            "::",
            stringify!(unused)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s__bindgen_ty_1>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s__bindgen_ty_1),
            "::",
            stringify!(count)
        )
    );
}
impl Default for uv_loop_s__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_loop_s__bindgen_ty_2 {
    pub min: *mut ::std::os::raw::c_void,
    pub nelts: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_uv_loop_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<uv_loop_s__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(uv_loop_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_loop_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_loop_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s__bindgen_ty_2>())).min as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s__bindgen_ty_2),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s__bindgen_ty_2>())).nelts as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s__bindgen_ty_2),
            "::",
            stringify!(nelts)
        )
    );
}
impl Default for uv_loop_s__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_uv_loop_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_loop_s>(),
        1072usize,
        concat!("Size of: ", stringify!(uv_loop_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_loop_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_loop_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).active_handles as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(active_handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).handle_queue as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).active_reqs as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(active_reqs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).stop_flag as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(stop_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).backend_fd as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(backend_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).pending_queue as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(pending_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).watcher_queue as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(watcher_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).watchers as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(watchers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).nwatchers as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(nwatchers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).nfds as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(nfds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).wq as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(wq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).wq_mutex as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(wq_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).wq_async as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(wq_async)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).cloexec_lock as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(cloexec_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).closing_handles as *const _ as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(closing_handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).process_handles as *const _ as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(process_handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).prepare_handles as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(prepare_handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).check_handles as *const _ as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(check_handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).idle_handles as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(idle_handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).async_handles as *const _ as usize },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(async_handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).async_unused as *const _ as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(async_unused)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).async_io_watcher as *const _ as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(async_io_watcher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).async_wfd as *const _ as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(async_wfd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).timer_heap as *const _ as usize },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(timer_heap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).timer_counter as *const _ as usize },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(timer_counter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).time as *const _ as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).signal_pipefd as *const _ as usize },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(signal_pipefd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).signal_io_watcher as *const _ as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(signal_io_watcher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).child_watcher as *const _ as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(child_watcher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).emfile_fd as *const _ as usize },
        952usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(emfile_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).cf_thread as *const _ as usize },
        960usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(cf_thread)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>()))._cf_reserved as *const _ as usize },
        968usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(_cf_reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).cf_state as *const _ as usize },
        976usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(cf_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).cf_mutex as *const _ as usize },
        984usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(cf_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).cf_sem as *const _ as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(cf_sem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).cf_signals as *const _ as usize },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(cf_signals)
        )
    );
}
impl Default for uv_loop_s {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
